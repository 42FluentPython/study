# 14. Inheritance: For Beter or Worse
- 다음 네 종류에 대해서 이야기 할 것.
  - `super()` 함수.
  - 내장 타입을 상속할 때의 위험성
  - 다중 상속과 메소드 결정 순서
  - Mixin 클래스

## `super()` 함수
- 직접 수퍼클래스를 호출하는 것은 권장되지 않는다.
  - 하드코딩임.
- `super()` 함수에는 숨겨진 두 개의 인자가 있다. 이전에는 super을 호출할 때 둘 다 명시적으로 넘겨줘야 했다.
  - `type`: 찾아야 할 수퍼클래스의 시작점이 되는 타입. 기본값은 `super()`이 호출되 메소드의 클래스.
  - `object_or_type`: 메소드 호출의 수신자가 되는 객체나 클래스. 객체에서는 기본적으로 self.
  - 이런 인자들은 테스트나 디버깅에만 쓰는 것이 좋다.

## 내장 타입을 상속하는 것은 조금 어렵다.
- 내장 타입을 상속했을 때, 상속한 내장 타입의 메소드가 사용자 정의 메소드를 호출하지 않는다.
  - C로 코딩되어있기 때문에
  - e.g. `get()`이 `__getitem__()`을 호출하지 않는다.
- 다른 내장 타입의 메소드도 사용자 정의 메소드를 호출하지 않는다.
  - `dict.update()`는 사용자 정의 `__getitem__`을 무시한다.
- 따라서, `UserDict`, `UserList`, `UserString` 등을 사용하자.

## 다중 상속과 메소드 결정 순서
- 메소드 결정과 `super()`로 호출되는 것은 `__mro__` 속성의 순서에 의해 결정된다.
  - 다중 상속 시 수퍼 클래스를 상속한 순서에 따라 결정된다.
  - `__mro__`는 인스턴스 속성이다.
  - 첫 번째 수퍼 클래스에서 `super()`을 호출하더라도 인스턴스의 `__mro__` 순서에 의해 결정된다.
- 너비 우선 탐색처럼 보이는데 실제로는 C3 알고리즘을 사용한다.

## mixin 클래스
- mixin 클래스는 다른 클래스와 함께 상속되도록 설계한 클래스이다.
- 구체 클래스는 mixin 만들 상속해서 만들어서는 안 된다.
- 자식이나 자매 클래스를 사용자화하기 위해 설계되었다.
- ...
  - `UpperCaseMixin`과 `UserDict`를 이용한 예시

## 실세계의 다중 상속
### ABC도 mixin이다.
- ABC는 인터페이스 정의이면서 mixin 클래스이다.
- `collections.UserDict`는 `collections.abc.MutableMapping`을 상속한다.

### ThreadingMixIn and ForkingMixIn
- 생략

### Django Generic Views Mixins
- 생략

### Multiple Inheritance in Tkinter
- 생략 (스파게티 상속)

## 상속 다루기
- 몇 가지 룰과 패턴과 안티 패턴이 있지만, 모든 경우에 해당하는 룰은 없다.

### 클래스 상속보다 객체 구성을 선호
- 상속에 익숙해지면 너무 많이 쓰게 된다.
  - 깔끔한 계층 구조는 정리가 잘 된 것처럼 보인다.
  - 프로그래머들은 재미를 위해서 구현한다.
- "is-a" 에 해당하는 경우에만 상속을 고려하라.
- 긴 상속 트리는 깨지기 쉽고, tight-coupling.
- 구성과 위임은 mixin을 대신할 수 있다.
  - 타입의 계층을 만들기 위한 인터페이스 상속은 대신할 수 없다.

### 상속이 왜 쓰이는지 이해하기
- 인터페이스 상속은 하위타입을 생성한다.
  - "is-a" 관계이다.
  - ABC를 통해서 하는 것이 가장 좋다.
- 구현을 상속하는 것은 반복 코드를 줄여준다.
  - mixin은 이 경우에 유용하다.
- 실제 사용에 있어서 둘 모두가 사용되는 경우가 많다.
  - 의도를 확실하게 할 수 있을 때는 반드시 해라.
- 코드 재사용을 위한 구현 상속은 보통 구성과 위임으로 해결할 수 있다.
- 인터페이스 상속은 프레임워크의 중요한 부분이다.
  - 인터페이스 상속을 사용할 때는 ABC만 사용하는 것이 좋다.

### ABC를 통해 인터페이스를 명시하기
- 인터페이스를 정의할 때, ABC나 `typing.Procotol`을 명시적으로 사용하여야 한다.
- ABC는 `abc.ABC`나 다른 ABC만을 상속해야한다.
  - ABC는 다중 상속이 문제가 안 된다.

### 코드 재사용 시 명시적 mixin을 사용해라
- 서로 관계없는 클래스들에서 코드 재사용을 할 때에는 명시적 mixin 클래스를 사용할 수 있다.
  - "is-a" 관계가 아님
- mixin은 새로운 타입을 정의하지 않는다.
  - 재사용을 위한 코드의 집합일 뿐이다.
- mixin은 인스턴스화되어서는 안된다.
- 하나의 mixin은 하나의 특정 행동만을 해야한다.
  - 아주 밀접하게 연관된 소수의 메소드만을 구현해야한다.
  - 내부 상태를 가져서는 안된다.
    - 즉, 속성(attr)이 있어서는 안된다.
- mixin을 표시하는 공식적인 문법은 없다.
  - 이름에 "Mixin" 접미어를 붙이는 것이 좋다.

### 유저에게 결합 클래스를 제공하기
- 믹스인과 다른 클래스를 상속받기만 하고, 추가로 구현하는 부분이 없는 클래스를 결합 클래스라고 한다.
- 결합 클래스는 항상 비어있을 필요는 없다. 그러나 보통 그렇다.

### 상속이 의도된 클래스만 상속하기
- 복잡한 클래스를 상속하고 메소드를 오버라이딩 하는 것은 에러의 가능성을 높인다.
  - 수퍼클래스가 서브클래스의 오버라이드를 무시하면서 의도하지 않은 대로 작동할 수 있다.
- 클래스가 상속될 의도로 설계되었다는 것을 어떻게 알 수 있을까?
  - "Base" 접두어가 붙은 클래스는 보통 상속을 위해 설계된 것이다.
  - 문서와 docstring에 써있음.
- `@final` 데코레이터는 정적 검사 때 상속을 막아준다.

### 구체 클래스를 상속하는 것을 피하라
- 구체 클래스를 상속하는 것은 ABC나 mixin을 상속하는 것보다 위험하다.
- 구체 클래스의 인스턴스는 보통 내부 상태가 있다.
  - 내부 상태에 의존하는 메소드를 오버라이딩하면 오염된다.
  - 오버라이딩 시 `super()`을 호출하고, 내부 상태를 `__x` 문법을 통해 프라이빗으로 만들더라도 생길 수 있는 오류는 많다.
- 추상 클래스가 아닌 구체 클래스를 상속하면 안된다.
- 코드 재사용을 위해 구체 클래스를 상속해야 한다면 mixin으로 분리해야한다.

### Tkinter: The Good, the Bac, and the ugly
- 생략

### Soapbox
- 개발자 중 다수는 애플리케이션 개발을 하지, 프레임워크를 개발하지는 않는다.
  - 프레임워크를 개발하는 사람도 많은 시간을 애플리케이션 개발에 쓴다.
- 애플리케이션 개발에는 클래스 계층이 필요가 없다.
  - 대부분은 ABC나 프레임워크에서 제공하는 다른 클래스를 상속한다.
  - 다른 클래스의 수퍼클래스를 작성하는 일은 보통 없다.
  - 생산하는 대부분의 클래스는 leaf 클래스이다.
- 다수준의 클래스 계층을 생산하고 있다면, 다음을 가능성을 생각해봐야한다.
  - 바퀴를 다시 개발하고 있는 경우.
    - 프레임워크나 라이브러리를 써라
  - 잘못 설계된 프레임워크를 사용하는 경우
    - 다른 프레임워크로 갈아타라.
  - overengineering.
    - KISS 원칙을 기억하라.
  - 애플리케이션 개발이 지루해서 프레임워크를 개발하기 시작한 것
    - 축하합니다~
